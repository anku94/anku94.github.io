<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://anku94.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://anku94.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-09T00:10:49+00:00</updated><id>https://anku94.github.io/feed.xml</id><title type="html">Ankush Jain</title><subtitle>Assorted systems musings </subtitle><entry><title type="html">Playing With Perf Probes</title><link href="https://anku94.github.io/blog/2023/perf-probes/" rel="alternate" type="text/html" title="Playing With Perf Probes"/><published>2023-09-08T19:56:00+00:00</published><updated>2023-09-08T19:56:00+00:00</updated><id>https://anku94.github.io/blog/2023/perf-probes</id><content type="html" xml:base="https://anku94.github.io/blog/2023/perf-probes/"><![CDATA[<p>This post demonstrates the power of perf probes, using the following example C code. Let’s say we’d like to verify that usleep actually sleeps for the claimed amount of time. This is the output we can get.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sleep Arg: 0 us, Sleep Time: 92 us
Sleep Arg: 100 us, Sleep Time: 167 us
Sleep Arg: 200 us, Sleep Time: 262 us
Sleep Arg: 300 us, Sleep Time: 370 us
Sleep Arg: 400 us, Sleep Time: 468 us
Sleep Arg: 500 us, Sleep Time: 584 us
Sleep Arg: 600 us, Sleep Time: 684 us
Sleep Arg: 700 us, Sleep Time: 784 us
Sleep Arg: 800 us, Sleep Time: 885 us
</code></pre></div></div> <p>Code for this exercise.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">add_with_sleep</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sleep_us</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">usleep</span><span class="p">(</span><span class="n">sleep_us</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">+=</span> <span class="n">add_with_sleep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I: %d, Ret: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Series of commands. You can run them line by line.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>

setup<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="nt">-1</span> | <span class="nb">sudo tee</span> /proc/sys/kernel/perf_event_paranoid
<span class="o">}</span>

run<span class="o">()</span> <span class="o">{</span>
  gcc <span class="nt">-g</span> <span class="nt">-o</span> code code.c
  ./code

  <span class="nb">alias </span><span class="nv">perf</span><span class="o">=</span>~/.local/bin/perf

  <span class="c"># -g enables call graph</span>
  perf record <span class="nt">-g</span> ./code

  <span class="c"># DWARF enables better stack unwinding</span>
  perf record <span class="nt">-g</span> <span class="nt">--call-graph</span><span class="o">=</span>dwarf ./code
  perf report <span class="nt">--stdio</span>

  <span class="c"># Show probe-able functions in binary</span>
  perf probe <span class="nt">-x</span> ./code <span class="nt">-F</span>

  <span class="c"># Show probe-able function lines in binary</span>
  perf probe <span class="nt">-x</span> ./code <span class="nt">-L</span> add_with_sleep

  <span class="c"># Show probe-able function lines in binary</span>
  perf probe <span class="nt">-x</span> ./code <span class="nt">-L</span> add_with_sleep:2

  <span class="c"># Show available variables at some point</span>
  perf probe <span class="nt">-x</span> ./code <span class="nt">-V</span> add_with_sleep:2

  <span class="c"># Add probes for function entry and exit. At entry, we also capture the arg.</span>
  <span class="c"># If the arg is say a string, we can specify varname:string to deref the str ptr.</span>
  <span class="nb">sudo </span>perf probe <span class="nt">-x</span> ./code <span class="nt">--add</span><span class="o">=</span><span class="s1">'add_with_sleep:0 sleep_us'</span>
  <span class="nb">sudo </span>perf probe <span class="nt">-x</span> ./code <span class="nt">--add</span><span class="o">=</span><span class="s1">'add_with_sleep%return'</span>

  <span class="nb">sudo </span>perf record <span class="nt">-e</span> probe_code:add_with_sleep <span class="nt">-e</span> probe_code:add_with_sleep__return ./code

  <span class="c"># This will generate a python script called perf-script.py</span>
  <span class="c"># Modify its entry and exit functions to print deltas between</span>
  <span class="c"># Entry and Exit timesteps</span>
  perf script <span class="nt">-g</span> python

  <span class="nb">sudo chown</span> <span class="si">$(</span><span class="nb">whoami</span><span class="si">)</span> perf.data
  perf script <span class="nt">-s</span> perf-script.py | less

  <span class="c">## Cleanup ##</span>

  <span class="c"># Should show two events</span>
  <span class="nb">sudo </span>perf probe <span class="nt">-l</span>
  <span class="nb">sudo </span>perf probe <span class="nt">-d</span> <span class="s1">'add_with_sleep'</span>
  <span class="nb">sudo </span>perf probe <span class="nt">-d</span> <span class="s1">'add_with_sleep%return'</span>
  <span class="c"># Should show zero events</span>
  <span class="nb">sudo </span>perf probe <span class="nt">-l</span>


<span class="o">}</span>

run
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">perf script -g python</code> will generate a file that looks something like this. Incorporate these changes into the script.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">start_arg</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">probe_code__add_with_sleep</span><span class="p">(</span><span class="n">event_name</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">common_cpu</span><span class="p">,</span> <span class="p">...):</span>
    <span class="k">global</span> <span class="n">start</span><span class="p">,</span> <span class="n">start_arg</span>
    <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">common_secs</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span> <span class="o">+</span> <span class="n">common_nsecs</span>
    <span class="n">start_arg</span> <span class="o">=</span> <span class="n">sleep_us</span>

<span class="k">def</span> <span class="nf">probe_code__add_with_sleep__return</span><span class="p">(</span><span class="n">event_name</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">common_cpu</span> <span class="p">...):</span>
    <span class="k">global</span> <span class="n">start</span><span class="p">,</span> <span class="n">start_arg</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">common_secs</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span> <span class="o">+</span> <span class="n">common_nsecs</span>
    <span class="n">time_usec</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e3</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Sleep Arg: {:.0f} us, Sleep Time: {:.0f} us</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">start_arg</span><span class="p">,</span> <span class="n">time_usec</span><span class="p">))</span>
</code></pre></div></div> <h3 id="credits">CREDITS</h3> <ol> <li><a href="https://bristot.me/using-perf-probe-to-measure-execution-time-of-user-space-code-on-linux/">https://bristot.me/using-perf-probe-to-measure-execution-time-of-user-space-code-on-linux/</a></li> <li><a href="http://notes.secretsauce.net/notes/2019/12/16_c-probes-with-perf.html">http://notes.secretsauce.net/notes/2019/12/16_c-probes-with-perf.html</a></li> <li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/monitoring_and_managing_system_status_and_performance/creating-custom-circular-buffers-to-collect-specific-data-with-perf_monitoring-and-managing-system-status-and-performance">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/monitoring_and_managing_system_status_and_performance/creating-custom-circular-buffers-to-collect-specific-data-with-perf_monitoring-and-managing-system-status-and-performance</a></li> <li><a href="http://blog.vmsplice.net/2011/03/how-to-use-perf-probe.html">http://blog.vmsplice.net/2011/03/how-to-use-perf-probe.html</a></li> <li><a href="http://oliveryang.net/2016/07/linux-perf-tools-tips/">http://oliveryang.net/2016/07/linux-perf-tools-tips/</a></li> </ol>]]></content><author><name></name></author><category term="systems"/><category term="perf"/><summary type="html"><![CDATA[Using perf probes for dynamic instrumentation]]></summary></entry><entry><title type="html">Profiling MPI with Perf</title><link href="https://anku94.github.io/blog/2023/profiling-mpi-with-perf/" rel="alternate" type="text/html" title="Profiling MPI with Perf"/><published>2023-09-05T00:29:25+00:00</published><updated>2023-09-05T00:29:25+00:00</updated><id>https://anku94.github.io/blog/2023/profiling-mpi-with-perf</id><content type="html" xml:base="https://anku94.github.io/blog/2023/profiling-mpi-with-perf/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">Notes on MPI+X vs Chapel</title><link href="https://anku94.github.io/blog/2023/notes-on-mpix-vs-chapel/" rel="alternate" type="text/html" title="Notes on MPI+X vs Chapel"/><published>2023-08-31T00:57:36+00:00</published><updated>2023-08-31T00:57:36+00:00</updated><id>https://anku94.github.io/blog/2023/notes-on-mpix-vs-chapel</id><content type="html" xml:base="https://anku94.github.io/blog/2023/notes-on-mpix-vs-chapel/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">On MMIO, DMA, and PCIe 3.0</title><link href="https://anku94.github.io/blog/2023/on-mmio-dma-and-pcie-30/" rel="alternate" type="text/html" title="On MMIO, DMA, and PCIe 3.0"/><published>2023-07-13T03:42:32+00:00</published><updated>2023-07-13T03:42:32+00:00</updated><id>https://anku94.github.io/blog/2023/on-mmio-dma-and-pcie-30</id><content type="html" xml:base="https://anku94.github.io/blog/2023/on-mmio-dma-and-pcie-30/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">On Taylor Swift, Tickets, and Scale</title><link href="https://anku94.github.io/blog/2022/on-taylor-swift-tickets-and-scale/" rel="alternate" type="text/html" title="On Taylor Swift, Tickets, and Scale"/><published>2022-11-18T18:55:38+00:00</published><updated>2022-11-18T18:55:38+00:00</updated><id>https://anku94.github.io/blog/2022/on-taylor-swift-tickets-and-scale</id><content type="html" xml:base="https://anku94.github.io/blog/2022/on-taylor-swift-tickets-and-scale/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">notes on linux graphics</title><link href="https://anku94.github.io/blog/2022/notes-on-linux-graphics/" rel="alternate" type="text/html" title="notes on linux graphics"/><published>2022-08-27T03:28:20+00:00</published><updated>2022-08-27T03:28:20+00:00</updated><id>https://anku94.github.io/blog/2022/notes-on-linux-graphics</id><content type="html" xml:base="https://anku94.github.io/blog/2022/notes-on-linux-graphics/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">On doorbells/NVMe etc.</title><link href="https://anku94.github.io/blog/2022/on-doorbellsnvme-etc/" rel="alternate" type="text/html" title="On doorbells/NVMe etc."/><published>2022-08-24T19:48:53+00:00</published><updated>2022-08-24T19:48:53+00:00</updated><id>https://anku94.github.io/blog/2022/on-doorbellsnvme-etc</id><content type="html" xml:base="https://anku94.github.io/blog/2022/on-doorbellsnvme-etc/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">On B+ Trees vs LSM Trees</title><link href="https://anku94.github.io/blog/2022/on-b-trees-vs-lsm-trees/" rel="alternate" type="text/html" title="On B+ Trees vs LSM Trees"/><published>2022-08-24T19:27:39+00:00</published><updated>2022-08-24T19:27:39+00:00</updated><id>https://anku94.github.io/blog/2022/on-b-trees-vs-lsm-trees</id><content type="html" xml:base="https://anku94.github.io/blog/2022/on-b-trees-vs-lsm-trees/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">notes on ebpf/kernel bypass/storage latency</title><link href="https://anku94.github.io/blog/2022/notes-on-ebpfkernel-bypassstorage-latency/" rel="alternate" type="text/html" title="notes on ebpf/kernel bypass/storage latency"/><published>2022-08-24T19:03:40+00:00</published><updated>2022-08-24T19:03:40+00:00</updated><id>https://anku94.github.io/blog/2022/notes-on-ebpfkernel-bypassstorage-latency</id><content type="html" xml:base="https://anku94.github.io/blog/2022/notes-on-ebpfkernel-bypassstorage-latency/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">Python multiprocessing OOM handling</title><link href="https://anku94.github.io/blog/2022/python-multiprocessing-oom-handling/" rel="alternate" type="text/html" title="Python multiprocessing OOM handling"/><published>2022-07-22T21:42:39+00:00</published><updated>2022-07-22T21:42:39+00:00</updated><id>https://anku94.github.io/blog/2022/python-multiprocessing-oom-handling</id><content type="html" xml:base="https://anku94.github.io/blog/2022/python-multiprocessing-oom-handling/"><![CDATA[]]></content><author><name></name></author></entry></feed>