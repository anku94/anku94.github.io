"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[26],{9026:function(e,t,s){s.r(t),s.d(t,{default:function(){return BudgetDataSankey}});var o=s(7437),a=s(5100),n=s(2265),l=s(7022);let Defaults=class Defaults{};Defaults.SANKEY_EDGE_COLOR="#abcdef",Defaults.SANKEY_NODE_COLOR="#cccccc",Defaults.SANKEY_URL="/dash/data/sankey/sankey.v7.json",Defaults.SANKEY_FILE_PREFIX="/dash/data/sankey/sections",Defaults.SAANKEY_FILES=["goi.json","g2_mor.json","g2_moha.json"],Defaults.SANKEY_FILES=["g2_mord.json","major_schemes.json","g2_moc.json","g2_other.json","g2_mocafpd.json","goi.json","g2_moe.json","g2_moea.json","metadata.json","g2_mod.json","subsidies.json","g2_moaafw.json","g2_mortah.json","g2_mojs.json","g2_mohafw.json","all_salaries.json","g2_mor.json","pensions.json","g2_mof.json","g2_mocaf.json","salaries.json","g2_doae.json","g2_moha.json"];var r=s(3832),c=s.n(r),d=s(6324),i=s.n(d);function getEdgeColor(e){let t=i()(e);return(t=(t=(t=t.brighten()).desaturate(1.5)).alpha(.35)).hex()}let SankeyUtils=class SankeyUtils{static traverseSankeyData(e){let t={in_count:0,in_sum:0,out_count:0,out_sum:0},s=new Map;e.edges.forEach(e=>{let o=s.get(e.src)||Object({...t}),a=s.get(e.dest)||Object({...t});o.out_count+=1,o.out_sum+=e.value,a.in_count+=1,a.in_sum+=e.value,s.set(e.src,o),s.set(e.dest,a)});let o=[],a=[];for(let[e,t]of s)0==t.in_count&&o.push(e),0==t.out_count&&a.push(e);return 1!=o.length&&(console.log("!!! WARN: Multiple root nodes: ",o),console.log("Root nodes: ",o)),o[0],{roots:o,leaves:a,leaf_values:a.map(e=>s.get(e).in_sum)}}static colorSankeyNodes(e,t){let s=new Map;e.edges.forEach(e=>{s.has(e.src)||s.set(e.src,[]),s.get(e.src).push(e.dest)});let o=new Map,a=new Map,dfs=(e,t)=>{o.has(t)||(o.set(t,[]),a.set(e,t)),o.get(t).push(e),a.set(e,t),s.has(e)&&s.get(e).forEach(e=>{dfs(e,t+1)})},n=new Map;dfs(t,0);let l=c()(60),r=1;for(let[e,a]of(n.set(t,l[0]),o)){if(0==e||2==e)continue;let t=new Set(a);t.forEach(e=>{n.set(e,l[r]);let t=s.get(e);null==t||t.forEach(e=>{n.set(e,l[r])}),r++})}let d=[];return e.edges.forEach(e=>{let t=a.get(e.src);if(t<=1){let t=getEdgeColor(n.get(e.src));d.push(t)}else if(2==t){let t=n.get(e.dest),s=getEdgeColor(n.get(e.dest));console.log("----> in src_2, edge_color: ",e.src,e.dest,s),console.log("dest_color: ",t,"edge_color: ",s),d.push(s)}else{let e=Defaults.SANKEY_EDGE_COLOR;d.push(e)}}),console.log("Sankey levels: ",o),console.log("Sankey levels rev: ",a),console.log("Color map: ",n),console.log("Edge colors: ",d),{node_colors:n,edge_colors:d}}static processSankeySectionExtent(e,t,s,o){let a={},n=SankeyUtils.traverseSankeyData({context:e,nodes:t,edges:s,positions:{}});if(1!=n.roots.length){let e=s.map(e=>e.dest);return e.map(e=>{a[e]=o}),a}let l=n.roots[0],r=new Map,dfs=(e,t)=>{r.has(t)||r.set(t,[]),r.get(t).push(e);let o=s.filter(t=>t.src==e).map(e=>e.dest);r.has(t+1)?r.get(t+1).push(...o):r.set(t+1,o),o.forEach(e=>{dfs(e,t+1)})};dfs(l,0);let c=parseInt(o.x.substring(1));for(let[e,t]of r)0!=e&&t.forEach((t,s)=>{let n={x:"l".concat(c+e-1),y:o.y};a[t]=n});return a}static removeUnconnectedNodes(e){let t={context:e.context,nodes:{},edges:[],positions:{}};t.edges=e.edges;let s=[...e.edges.map(e=>e.src),...e.edges.map(e=>e.dest)],o=new Map(s.map(e=>[e,!0]));for(let[s,a]of Object.entries(e.nodes))o.has(s)&&(t.nodes[s]=a);for(let[s,a]of Object.entries(e.positions))o.has(s)&&(t.positions[s]=a);return t}static simplifySankeyData(e){let t=SankeyUtils.traverseSankeyData(e);if(1!=t.roots.length)return e;let s=t.roots[0],o=t.leaves.map((e,o)=>({src:s,dest:e,value:t.leaf_values[o],color:Defaults.SANKEY_EDGE_COLOR})),a=new Map;return a.set(s,e.nodes[s]),t.leaves.map(t=>{a.set(t,e.nodes[t])}),{context:e.context,nodes:Object.fromEntries(a),edges:o,positions:e.positions}}static fillUnallocatedEdge(e){let t=new Map;for(let s of(console.log("In Fill Unallocated Edge: ",e.edges),e.edges)){let e=t.get(s.src)||0;t.set(s.src,e-s.value);let o=t.get(s.dest)||0;t.set(s.dest,o+s.value)}console.log("Node Map: ",t);let s=e.edges.map(e=>(-1==e.value&&(console.log(e),e.value=t.get(e.src)),e));return{context:e.context,nodes:e.nodes,edges:s,positions:e.positions}}static getXposNext(e){let t=parseInt(e.substring(1)),s="l"+(t+1).toString();return s}static getPosNext(e){console.log("In pos_next: ",e);let t={x:e.x,y:e.y};return t.x=SankeyUtils.getXposNext(e.x),t}static resolveNodePosition(e,t){let s={x:0,y:0};return s.x=t.xpos[e.x],s.y=t.ypos[e.y],s}static foldEdges(e,t){let s=[],o={},a={},n={};e.edges.forEach(l=>{if(l.value<t){if(s.push(l),o[l.src])o[l.src].value+=l.value;else{if(!e.nodes[l.src]){console.log("!!! NOT FOUND: ",l.src);return}o[l.src]={src:l.src,dest:l.src+"_others",value:l.value,color:l.color};let t=e.nodes[l.src],s=t.split(" ").map(e=>e[0]).join("").toLocaleUpperCase(),r="".concat(l.src,"_others");a[r]="".concat(s," (Others)"),n[r]=e.positions[l.dest]}}});let l=e.edges.filter(e=>!s.includes(e)),r={};return Object.values(o).forEach(e=>{e.value>t&&(l.push(e),r[e.dest]=a[e.dest])}),{...e,nodes:{...e.nodes,...r},edges:l,positions:{...e.positions,...n}}}static sortSankeyData(e,t){let s=[],o=new Set;function dfs(t){if(o.has(t))return;o.add(t);let a=e.edges.filter(e=>e.src===t).sort((e,t)=>t.value-e.value);for(let e of a)s.push(e),dfs(e.dest)}return dfs(t),{...e,edges:s}}static processSankeySection(e,t){let s=t.active;if(!(e.id&&s.includes(e.id)))return{context:t,nodes:{},edges:[],positions:{}};e.nodes,e.edges.map(e=>({src:e[0],dest:e[1],value:e[2],color:Defaults.SANKEY_EDGE_COLOR}));let o={context:t,nodes:e.nodes,edges:e.edges.map(e=>({src:e[0],dest:e[1],value:e[2],color:Defaults.SANKEY_EDGE_COLOR})),positions:{}};return(o=SankeyUtils.removeUnconnectedNodes(o)).positions=SankeyUtils.processSankeySectionExtent(t,o.nodes,o.edges,e.pos),"goi"==e.id&&(o.positions[t.root]=t.position),o}static computeCustomData(e){let t=new Map,getNodeData=e=>t.has(e)?t.get(e):{sum_src:0,sum_dest:0};e.edges.forEach(e=>{let s=getNodeData(e.src),o=getNodeData(e.dest);s.sum_src+=e.value,o.sum_dest+=e.value,t.set(e.src,s),t.set(e.dest,o)});let s=new Map,amount_str=e=>{let t=1e7*e,s=(t/1e12).toFixed(1),o=(t/(82*1e9)).toFixed(1),a="$".concat(o,"B (").concat("₹").concat(s,"L Cr)");return a};for(let[o,a]of t){let t=amount_str(a.sum_src),n=0==a.sum_dest?a.sum_src:a.sum_dest,l=amount_str(n),r=amount_str(n-a.sum_src),c=e.nodes[o],d="<b>Head: ".concat(c,"</b><br>")+"Amount: ".concat(l,"<br>"),i="Allocated here: ".concat(t,"<br>")+"Unallocated: ".concat(r);0!=a.sum_dest&&0!=a.sum_src?s.set(o,d+i):s.set(o,d)}let o=e.edges.map(t=>{let s=e.nodes[t.src],o=e.nodes[t.dest],a=amount_str(t.value),n="".concat(s," → ").concat(o,"<br />")+"<b>Amount: ".concat(a,"</b><br />");return n});return{node_labels:s,edge_labels:o}}static mergeGraphData(e){let t=e.metadata.root,s=e.metadata.position,o=e.metadata,a={context:o,nodes:{},edges:[],positions:{}};a.positions[t]=s,e.data.forEach(e=>{let{nodes:t,edges:s,positions:n}=SankeyUtils.processSankeySection(e,o);console.log("Processed Data: ",t,s,n),Object.assign(a.nodes,t),Object.assign(a.positions,n),a.edges.push(...s)});let n=SankeyUtils.fillUnallocatedEdge(a),l=SankeyUtils.colorSankeyNodes(n,t);n.colors=Object.fromEntries(l.node_colors),n.edges.forEach((e,t)=>{e.color=l.edge_colors[t]});let r=SankeyUtils.foldEdges(n,1e4),c=SankeyUtils.sortSankeyData(r,t);return console.log("Merged Data: ",a),console.log("Data W/ Unalloc",n),console.log("Data folded: ",r),console.log("Data sorted: ",c),c}};function serializeNodes(e){let t=new Map,s=[],o=0;return e.forEach(e=>{t.has(e.src)||(t.set(e.src,o++),s.push(e.src)),t.has(e.dest)||(t.set(e.dest,o++),s.push(e.dest))}),s}function convertGraphDataToPlotData(e){let t=SankeyUtils.mergeGraphData(e),s=SankeyUtils.computeCustomData(t),o=t.nodes,a=serializeNodes(t.edges),n=new Map;serializeNodes(t.edges).forEach((e,t)=>{n.set(e,t)});let l=a.map(e=>SankeyUtils.resolveNodePosition(t.positions[e],t.context)),r=t.edges,c={label:a.map(e=>o[e]),link:{source:r.map(e=>n.get(e.src)),target:r.map(e=>n.get(e.dest)),value:r.map(e=>e.value),color:r.map(e=>e.color),customdata:s.edge_labels},node:{x:l.map(e=>e.x||0),y:l.map(e=>e.y||0),color:a.map(e=>{var s;return(null===(s=t.colors)||void 0===s?void 0:s[e])||Defaults.SANKEY_NODE_COLOR}),customdata:a.map(e=>s.node_labels.get(e)||"")}};return console.log("Plot Data: ",c),c}async function fetchJsonArray(e){try{let t=await Promise.all(e.map(e=>fetch(Defaults.SANKEY_FILE_PREFIX+"/"+e)));t.forEach(e=>{if(!e.ok)throw Error("HTTP error! Status: ".concat(e.status))});let s=t.map(e=>e.json());return await Promise.all(s)}catch(e){throw console.error("Error fetching URLs:",e),e}}var SankeyPlotData=async function(e){let t=Defaults.SANKEY_FILE_PREFIX+"/metadata.json",s=await fetch(t),o=await s.json(),a=await fetchJsonArray(Defaults.SANKEY_FILES);return convertGraphDataToPlotData({metadata:o,data:a})},BudgetDataSankey=()=>{let{state:e,dispatch:t}=(0,n.useContext)(a.I),s={type:"sankey",orientation:"h",arrangement:"snap",domain:{x:[0,1],y:[0,1]},node:{pad:15,thickness:30,line:{color:"black",width:.5}}},applyData=e=>{var t,o,a,n,l;let r={...s,node:{...s.node,label:e.label,x:null===(t=e.node)||void 0===t?void 0:t.x,y:null===(o=e.node)||void 0===o?void 0:o.y,customdata:null===(a=e.node)||void 0===a?void 0:a.customdata,color:null===(n=e.node)||void 0===n?void 0:n.color,hoverinfo:"all",hovertemplate:"%{customdata}<extra></extra>",hoverlabel:{align:"left"}},link:{...e.link,hovertemplate:"%{customdata}<extra></extra>",hoverinfo:"all",hoverlabel:{align:"left"},customdata:null===(l=e.link)||void 0===l?void 0:l.customdata}};return r},[r,c]=(0,n.useState)([s]);return(0,n.useEffect)(()=>{SankeyPlotData(Defaults.SANKEY_URL).then(e=>{console.log(e);let t=applyData(e);c([t])})},[e.key]),(0,o.jsx)(l.Z,{data:r,layout:{font:{size:12},width:1280,height:1600,margin:{t:20,b:240,l:0,r:0,pad:2}}})}}}]);